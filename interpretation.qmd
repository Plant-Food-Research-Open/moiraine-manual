# Interpreting the integration results {#sec-interpretation}

```{r}
#| child: "_setup.qmd"
```

```{r loading-packages}
#| include: false

library(targets)
library(moiraine)
library(purrr)
library(dplyr)
library(ggplot2)
library(patchwork)
```

```{r setup-visible}
#| eval: false

library(targets)
library(moiraine)

## For working with lists
library(purrr)

## For data-frames manipulation
library(dplyr)

## For colour palettes
library(ggplot2)

## For manipulating patchworks of plots
library(patchwork)
```

<details>

<summary>`_targets.R` script</summary>

```{file targets-script}
```

::: {.panel-tabset group="method"}
#### sPLS

Tab content

#### sO2PLS

Tab content

#### MOFA

Tab content

#### DIABLO

Tab content
:::

</details>




## Generating a standardised output

Despite relying on very different statistical approaches, the different integration methods included in the pipeline all perform dimension reduction of the omics datasets through feature extraction. That is, they construct a small number of latent components/variables/dimensions (that we refer to as **latent dimensions** in the `moiraine` package) that capture as much information from the original datasets as possible. A dimension reduction approach typically returns, for each latent dimension constructed, two sets of values:

* **Features weight**: the contribution of the features from the different omics dataset to the latent dimension. All methods included in the pipeline construct latent dimensions as linear combinations of the original features, and therefore the features contribution is quantified by their weight in the linear combination.

* **Samples score**: the projection of the samples onto the latent dimension.

In addition, the fraction or percentage of variance that each latent dimension explains in the different omics datasets is usually calculated.

### `get_output` function


In the `moiraine` package, the output of the different integration methods can be converted to a standardised output containing these three pieces of information (features weight, samples score and percentage of variance explained) stored in a consistent format. This enables us to construct functions for visualisation or analysis which can be applied to the results of any integration method, rather than having to implement one for each object type returned by the different integration packages.

The `get_output()` function transforms the output from any integration package included in `moiraine` into an `output_dimension_reduction` object, which is a list with three tibbles: `features_weight`, `samples_score` and `variance_explained`:

::: {.panel-tabset group="method"}
#### sPLS

```{targets get-output-spls}
tar_target(
  spls_output,
  get_output(spls_final_run)
)
```

```{r show-output-spls}
tar_load(spls_output)
spls_output
```

#### sO2PLS

```{targets get-output-so2pls}
tar_target(
  so2pls_output,
  get_output(so2pls_final_run)
)
```

```{r show-output-so2pls}
tar_load(so2pls_output)
so2pls_output
```

#### MOFA

```{targets get-output-mofa}
tar_target(
  mofa_output,
  get_output(mofa_trained)
)
```

```{r show-output-mofa}
tar_load(mofa_output)
mofa_output
```

#### DIABLO

```{targets get-output-diablo}
tar_target(
  diablo_output,
  get_output(diablo_final_run)
)
```

```{r show-output-diablo}
tar_load(diablo_output)
diablo_output
```
:::

The `features_weight` tibble contains one row per combination of feature and latent dimension. The ID of the features and the name of the dataset from which they originate are stored in the `feature_id` and `dataset` columns, respectively. The `latent_dimension` column gives the name of the latent dimension; this is a factor column. For each feature and latent dimension, the `weight` column shows the weight that was attributed to the feature for the corresponding latent dimension. In addition, the `importance` column contains the features importance score, which is computed as the absolute value of the features weight, divided by the maximum absolute weight across all features from the same omics dataset for the corresponding latent dimension. This importance score allows us to compare the contribution of the features across latent dimensions or integration methods, as the weight can be on different scales and thus cannot be directly compared. The importance scores range from 0 to 1. For any method performing feature selection (e.g. sPLS or DIABLO), features that were not selected for a given latent dimension are assigned a weight and importance score of 0.

The `samples score` tibble contains for each sample (`sample_id`) and latent dimension (`latent_dimension`) the sample's coordinate for the corresponding latent dimension. 

The `variance_explained` tibble gives for each latent dimension (`latent_dimension`) the proportion of variance explained (`prop_var_expl`) for each dataset (`dataset`). The values in `prop_var_expl` are between 0 and 1.

For convenience, the `get_latent_dimensions()` function can be used on an `output_dimension_reduction` object to see the names of the latent dimensions (the levels used for the `latent_dimension` column in each tibble):

::: {.panel-tabset group="method"}
#### sPLS

```{r show-latent-dimensions-spls}
get_latent_dimensions(spls_output)
```


#### sO2PLS

```{r show-latent-dimensions-so2pls}
get_latent_dimensions(so2pls_output)
```

#### MOFA

```{r show-latent-dimensions-mofa}
get_latent_dimensions(mofa_output)
```

#### DIABLO

```{r show-latent-dimensions-diablo}
get_latent_dimensions(diablo_output)
```
:::

::: {.callout-note}
## Other methods covered by `get_output`

Note that both PCA and sPLS-DA (the method used for supervised features preselection in @sec-prefiltering-supervised) are also both dimension reduction methods. Therefore, the `get_output` function also converts `pcaRes` objects (from `run_pca()` or `pcaMethods::pca()`) and `mixo_splsda` objects (from `run_splsda()` or `mixOmics::splsda()`).
:::

### Averaging latent dimensions over datasets

While MOFA computes one score per sample for each latent dimension created, sPLS, DIABLO and sO2PLS all compute one score per dataset for each sample and latent dimension. For each latent dimension. the samples score obtained for the different datasets are then compared, to assess the agreement or covariation between datasets. Ideally, these scores should be highly correlated across datasets, since the methods aim at maximising the variation between datasets, but it is not always the case. However, when they are highly correlated, it becomes redundant to interpret the latent dimensions for each dataset.

Instead, the `mixOmics` authors proposed a solution for `DIABLO`, which is to construct a weighted average space: for each latent component, the samples score are averaged over the different datasets. The weight is given per dataset and determined by how well the corresponding dataset discriminate between the samples group of interest. This way, rather than looking at samples score for each dataset for any given latent component, we can look at an average of them.

The `get_output()` function uses this idea to construct, for the output of sPLS, sO2PLS and DIABLO a set of average samples score for each latent dimension, rather than returning a set of samples score per dataset. For DIABLO, the average is weighted as explained above, while for sPLS and sO2PLS each dataset is given equal weight in the average. This calculation can be disabled in the `get_output()` function to extract the dataset-specific samples score, by setting the `use_average_dimensions` parameter to `FALSE`. Note that this only affects the `samples_score` tibble in terms of dimensions, but the name of the latent dimensions will change to reflect the dataset to which they refer.

::: {.panel-tabset group="method"}
#### sPLS

```{targets get-output-spls-no-average}
tar_target(
  spls_output_no_average,
  get_output(spls_final_run, use_average_dimensions = FALSE)
)
```

```{r show-output-spls-no-average}
tar_load(spls_output_no_average)

get_latent_dimensions(spls_output_no_average)

nrow(spls_output$samples_score)
nrow(spls_output_no_average$samples_score)
```

#### sO2PLS

```{targets get-output-so2pls-no-average}
tar_target(
  so2pls_output_no_average,
  get_output(so2pls_final_run, use_average_dimensions = FALSE)
)
```

```{r show-output-so2pls-no-average}
tar_load(so2pls_output_no_average)

get_latent_dimensions(so2pls_output_no_average)

nrow(so2pls_output$samples_score)
nrow(so2pls_output_no_average$samples_score)
```

#### DIABLO

```{targets get-output-diablo-no-average}
tar_target(
  diablo_output_no_average,
  get_output(diablo_final_run, use_average_dimensions = FALSE)
)
```

```{r show-output-diablo-no-average}
tar_load(diablo_output_no_average)
  
get_latent_dimensions(diablo_output_no_average)

nrow(diablo_output$samples_score)
nrow(diablo_output_no_average$samples_score)
```
:::

## Interpretation

Interpreting the results of a dimension reduction method involves:

* Understanding the source of the variation captured by each latent dimension: is a given latent dimension representing an important source of biological variation, such as effect of a treatment, or age of the samples? Or do they show a source of technical variation, for example highlighting a group of outlier samples with different omics profiles from the rest of the observations? Answering these questions allows us to identify which latent dimensions capture the biological phenomenon investigated, or whether there are some sources of noise that should be accounted for in follow-up experiments.

* Investigating which omics features are driving the latent dimensions: once we have identified some latent dimensions of interest, we can look at the features that contribute the most to understand the molecular mechanisms or pathways involved. This is typically done after looking into the phenomenon captured by the latent dimensions, but can also help to identify it.



<!-- ## DIABLO -->

<!-- Some of the plots that will be used to interpret the results require us to transform the DIABLO result object into a standard "dimensions reduction output" object, through the `get_output()` function. The returned object contains the results of the DIABLO run stored in a standard way for the `moiraine` package, i.e. as a list with the samples scores for the different latent components stored in the `samples_score` element, the features loading for the latent components stored in the `features_weight` element, and the proportion of variance explained by each latent component in the corresponding dataset in the `variance_explained` element. -->

<!-- ```{targets diablo-output} -->
<!-- tar_target( -->
<!--   diablo_output, -->
<!--   get_output(diablo_final_run) -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r show-diablo-output} -->
<!-- tar_load(diablo_output) -->

<!-- diablo_output -->
<!-- ``` -->

<!-- Notice that in the `features_weight` table, the features loading for the latent components as computed by DIABLO is stored in the `weight` column. Then, a feature importance score is computed as `abs(weight) / abs(max(weight))`. It allows us to quickly filter the most important features, regardless of the sign of their contribution to the latent component and the scale of the loadings for the component. -->

<!-- By default, the `get_output` function will create a weighted average of each latent component across all datasets. This can be disabled by setting `use_average_dimensions = FALSE`, to extract the dataset-specific latent components. -->

<!-- ```{targets diablo-output-no-average} -->
<!-- tar_target( -->
<!--   diablo_output_no_average, -->
<!--   get_output(diablo_final_run, use_average_dimensions = FALSE) -->
<!-- ) -->
<!-- ``` -->

<!-- We can check which latent components are present with the `get_latent_dimensions()` function: -->

<!-- ```{r no-average-components} -->
<!-- get_latent_dimensions(diablo_output) -->
<!-- get_latent_dimensions(tar_read(diablo_output_no_average)) -->
<!-- ``` -->

<!-- ### Samples plots {#sec-interpretation-samples-scores} -->

<!-- More generally, we can plot the samples in the subspace spanned by the different components using the `plot_samples_score()` function. This function takes as input the DIABLO result in standardised format (from the `get_output()` function), and creates a matrix of scatter-plots to compare all possible pairs of components. The function also accepts a MultiDataSet object as an optional input, which can be used to enrich the plot with information about the samples extracted from the samples metadata. The plots in the resulting matrix are redundant: the lower plots (below the diagonal) are just a rotated version of the upper plots (above the diagonal); this is useful to represent several properties of the samples in one plot. For more details, see the help of the function. Here, we'll show in the upper plots the bruising groups and replicate ID, and in the lower plots the parents of each sample. -->

<!-- ```{r plot-samples-score-ggpairs} -->
<!-- #| fig.height = 10 -->

<!-- plot_samples_score( -->
<!--   diablo_output, -->
<!--   mo_data = tar_read(mo_set), -->
<!--   colour_upper = "status", -->
<!--   scale_colour_upper = scale_colour_brewer(palette = "Set1"), -->
<!--   shape_upper = "feedlot", -->
<!--   colour_lower = "geno_comp_cluster", -->
<!--   shape_lower = NULL -->
<!-- ) + -->
<!--   theme(legend.box = "vertical") -->
<!-- ``` -->

<!-- Remember, the `get_output()` function will by default compute a weighted average of the samples score across the datasets for each latent component, which is why we are seeing two latent components in the plot. -->

<!-- Two other related functions allow us to visualise the samples score in different ways. The `plot_samples_score_pair()` function creates a scatterplot of samples score for two user-selected latent components. The latent components must be selected by name, which we can find through: -->

<!-- ```{r latent-dimensions-levels} -->
<!-- get_latent_dimensions(diablo_output) -->
<!-- ``` -->

<!-- And, as for the previous example, the MultiDataSet object can be used to enrich the plot with samples properties: -->

<!-- ```{r plot-samples-score-pair} -->
<!-- plot_samples_score_pair( -->
<!--   diablo_output, -->
<!--   c("Component 1", "Component 2"), -->
<!--   mo_data = tar_read(mo_set), -->
<!--   colour_by = "status", -->
<!--   shape_by = "geno_comp_cluster" -->
<!-- ) + -->
<!--   scale_colour_brewer(palette = "Set1") -->
<!-- ``` -->

<!-- The `plot_samples_score_covariate()` function displays the samples score for each component against a samples covariate from the samples metadata. For example, to show the distribution of samples score between the different sibling groups, we can use: -->

<!-- ```{r plot-samples-score-covariate} -->
<!-- #| fig.height = 7, -->
<!-- #| fig.width = 8.5 -->

<!-- plot_samples_score_covariate( -->
<!--   diablo_output, -->
<!--   mo_data = tar_read(mo_set), -->
<!--   covariate = "status", -->
<!--   colour_by = "feedlot", -->
<!--   ncol = 1 -->
<!-- ) -->
<!-- ``` -->


<!-- Note that the function creates different plots depending on whether the covariate is categorical (as above) or numeric. For numerical variables, it will create scatterplots, e.g.: -->

<!-- ```{r plot-samples-score-covariate-numeric} -->
<!-- plot_samples_score_covariate( -->
<!--   diablo_output, -->
<!--   mo_data = tar_read(mo_set), -->
<!--   covariate = "day_on_feed", -->
<!--   colour_by = "feedlot", -->
<!--   latent_dimensions = "Component 1" -->
<!-- ) -->
<!-- ``` -->

<!-- ### Extracting the selected features -->

<!-- We can extract the features that were selected for the different latent components with the function `get_selected_features()`, which takes as input the DIABLO results in standardised format: -->

<!-- ```{r get-selected-features} -->
<!-- get_selected_features(diablo_output) |> -->
<!--   head() -->
<!-- ``` -->

<!-- The function returns a tibble indicating: -->

<!-- -   the features ID; -->

<!-- -   the dataset from which the features originate; -->

<!-- -   the latent component for which the features have been selected; -->

<!-- -   the features' loading for this latent component, i.e. their weight in the linear combination that constitutes the latent component; -->

<!-- - the features' importance score, i.e. their absolute weight divided by the maximum weight for the corresponding dataset and latent component. -->

<!-- By passing the original MultiDataSet object as input to this function, we can extract the feature metadata associated with the selected features: -->

<!-- ```{r get-selected-features-metadata} -->
<!-- get_selected_features( -->
<!--   diablo_output, -->
<!--   mo_data = tar_read(mo_set) -->
<!-- ) |> -->
<!--   head() -->
<!-- ``` -->

<!-- By default, the `get_selected_features()` function returns the selected features for all datasets and latent components, but we can focus on a subset of these by passing datasets or latent components names to the `datasets` and `latent_dimensions` parameters of the function. For example, let us get the selected features from the transcriptomics and metabolomics datasets for the first latent component: -->

<!-- ```{r get-selected-features-subset} -->
<!-- get_selected_features( -->
<!--   diablo_output, -->
<!--   latent_dimensions = "Component 1", -->
<!--   datasets = c("rnaseq", "metabolome"), -->
<!--   mo_data = tar_read(mo_set) -->
<!-- ) |> -->
<!--   head() -->
<!-- ``` -->

<!-- Alternatively, the `get_top_features()` function facilitates the extraction of the top contributing features per dataset and latent component. The function offers two options: -->

<!-- - select from each dataset the top N features that contribute the most to a latent component; N is set through the `n_features` argument of the function (note that if there are ties in the features importance all ties will be returned). -->

<!-- - select from each dataset all features that have an importance score equal to or greater than a certain threshold. The threshold is set through the `min_importance` argument of the function. -->

<!-- As for the `get_selected_features()` function, it is possible to focus on specific datasets and/or latent components, and to pass on a MultiDataSet object to extract features metadata. -->

<!-- ```{r get-top-features-n} -->
<!-- get_top_features(diablo_output, n_features = 3, mo_data = tar_read(mo_set)) |> -->
<!--   head() -->
<!-- ``` -->


<!-- ```{r get-top-features-min} -->
<!-- get_top_features(diablo_output, min_importance = 0.8, mo_data = tar_read(mo_set)) |> -->
<!--   head() -->
<!-- ``` -->


<!-- ### Visualising the top features -->

<!-- We can also look at the loading of the features from each dataset that most contribute to each of the latent components with the function `plot_top_features()`. The function takes as input the formatted DIABLO output. By default, feature IDs will be used as labels, but it is possible to make use of the feature metadata in our MultiDataSet object to label the features. In this example, we select columns from the feature metadata of the transcriptomics and metabolomics datasets to get more meaningful labels, but leave the SNPs' label to be their ID. -->

<!-- ```{r plot-top-features} -->
<!-- #| fig.width = 10, -->
<!-- #| fig.height = 7 -->

<!-- plot_top_features( -->
<!--   diablo_output, -->
<!--   mo_data = tar_read(mo_set), -->
<!--   label_cols = list( -->
<!--     "rnaseq" = "Name", -->
<!--     "metabolome" = "name" -->
<!--   ) -->
<!-- ) + -->
<!--   theme( -->
<!--     axis.text.y = element_text(size = 8) -->
<!--   ) -->
<!-- ``` -->

<!-- By default, the function displays the top 20 features per dataset and component, but that can be changed with the `n_features` dataset. If less than 20 features were selected for a given dataset and component, only the select features will be shown. -->


<!-- We can investigate further these features by looking at their measurements in the datasets, with the `plot_data_heatmap()` or `plot_data_covariate()` functions (more details in the vignettes on [Inspecting a MultiDataSet object](inspecting-multidataset.html#visualising-data)). We will extract the ID of the top 3 features from each dataset for component 1 with the `get_top_features()` that we saw in [the previous section](diablo-pipeline.html#extracting-the-selected-features): -->

<!-- ```{r get-top-features-list} -->
<!-- top_features <- get_top_features( -->
<!--   diablo_output, -->
<!--   n_features = 3, -->
<!--   latent_dimensions = "Component 1" -->
<!-- ) |>  -->
<!--   pull(feature_id) -->

<!-- top_features -->
<!-- ``` -->


<!-- We can visualise these features as a heatmap: -->

<!-- ```{r plot-data-heatmap-annotations, fig.width = 10} -->
<!-- plot_data_heatmap( -->
<!--   tar_read(mo_presel_supervised), -->
<!--   top_features, -->
<!--   center = TRUE, -->
<!--   scale = TRUE, -->
<!--   only_common_samples = TRUE, -->
<!--   show_column_names = FALSE, -->
<!--   samples_info = "status", -->
<!--   colours_list = list( -->
<!--     "status" = c("Control" = "gold", "BRD" = "lightblue") -->
<!--   ), -->
<!--   label_cols = list( -->
<!--     "rnaseq" = "Name", -->
<!--     "metabolome" = "name" -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->

<!-- or a violin plot against samples bruising group: -->

<!-- ```{r plot-data-covariate-categorical, fig.height = 5} -->
<!-- plot_data_covariate( -->
<!--   tar_read(mo_presel_supervised),  -->
<!--   "status", -->
<!--   top_features, -->
<!--   only_common_samples = TRUE, -->
<!--   label_cols = list( -->
<!--     "rnaseq" = "Name", -->
<!--     "metabolome" = "name" -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->


<!-- ### Comparing features importance between latent components -->

<!-- We can also compare the importance given to the features between any two latent components with the `plot_features_weight_pair()` function. -->

<!-- ```{r} -->
<!-- plot_features_weight_pair( -->
<!--   diablo_output, -->
<!--   c("Component 1", "Component 2"), -->
<!--   mo_data = tar_read(mo_set), -->
<!--   label_cols = list( -->
<!--     "rnaseq" = "Name", -->
<!--     "metabolome" = "name" -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->

<!-- In this case, the plot is not extremely interesting, but allows us to quickly confirm that different features were selected for the two latent components. The top 5 features according to their consensus importance (see section about [methods comparison](methods-comparison.html#feature-consensus-importance)) are highlighted in red. -->

<!-- By default, the function plots the signed importance score of the features, i.e. their importance score to which the sign of their weight was added. This can be changed through the `features_metric` argument of the function. -->
