[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The moiraine R package user manual",
    "section": "",
    "text": "Preface\nQuick blurb around multi-omics integration. There are many tools available to perform multi-omics integration, and a lot are implemented as R packages. These tools differ conceptually (in terms of required data input, assumptions, questions they answer) but also at a practical level in terms of input data format, parameters, etc and output format. That makes it time-consuming to apply different tools to a same multi-omics dataset, and to compare the results."
  },
  {
    "objectID": "index.html#the-moiraine-package",
    "href": "index.html#the-moiraine-package",
    "title": "The moiraine R package user manual",
    "section": "The moiraine package",
    "text": "The moiraine package\nThe moiraine package aims at alleviating this by providing a framework to easily and consistently apply different integration tools to a same dataset. It also facilitates the comparison of results with consistent formatting of integration output and visualisations.\nIn addition, in an effort to make these computations reproducible, moiraine heavily relies on targets for the creating of reproducible pipelines."
  },
  {
    "objectID": "index.html#about-this-manual",
    "href": "index.html#about-this-manual",
    "title": "The moiraine R package user manual",
    "section": "About this manual",
    "text": "About this manual\nIn this manual, we are showcasing the functionalities of the moiraine package by presenting an in-depth walk-through example of multi-omics integration analysis. This will not only talk about the how in terms of R functions etc, but also talk about the integration methods and how to use them.\nHere, say that we heavily recommend to be familiar with targets (teaching targets it out of the scope of this manual, and we refer to the excellent targets manual).\n\nlibrary(targets)\n\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n#> [1] 2\n\nA targets chunck:\n\ntar_target(a, 2+2)\n\n\n\n\"something\""
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "\n1  Introduction\n",
    "section": "",
    "text": "omics dataset + what are samples and features metadata\nwhat is multi-omics integration\nsupervised vs unsupervised\nthe analysis workflow from moiraine (use the graph I use in presentations)\n\n\n1.0.1 Other things to add in intro\nNote: Throughout the package and vignettes, we refer to the different biological entities measured in a given dataset (e.g. genes, transcripts, metabolic compounds, etc) as features."
  },
  {
    "objectID": "example_dataset.html",
    "href": "example_dataset.html",
    "title": "2  The example dataset",
    "section": "",
    "text": "The dataset that is used as example in this manual comes from Li et al. (2022). In this paper, the authors investigate the molecular mechanisms of bovine respiratory disease (BRD) in beef cattle, using multi-omics data. They collected genomics, transcriptomics and metabolomics measurements on blood samples obtained from both healthy and infected animals. They performed a genome-wide association study (GWAS) to identify genomic variants associated with BRD incidence, as well as a differential expression (DE) analysis on both the transcriptomics and metabolomics datasets to identify genes and metabolites whose expression or abundance differed between the two animal groups. They also performed an expression quantitative trait loci (eQTL) analysis to highlight associations between genomic variants and differentially expressed genes. The datasets analysed in this article are publicly available. In this chapter, we detail the content of each dataset, and how they were obtained and processed to use for this manual.\n\n\n\n\nLi, Jiyuan, Robert Mukiibi, Janelle Jiminez, Zhiquan Wang, Everestus C. Akanno, Edouard Timsit, and Graham S. Plastow. 2022. “Applying Multi-Omics Data to Study the Genetic Background of Bovine Respiratory Disease Infection in Feedlot Crossbred Cattle.” Frontiers in Genetics 13. https://www.frontiersin.org/articles/10.3389/fgene.2022.1046192."
  },
  {
    "objectID": "data_import.html#the-example-dataset-files",
    "href": "data_import.html#the-example-dataset-files",
    "title": "3  Importing data",
    "section": "\n3.1 The example dataset files",
    "text": "3.1 The example dataset files\nThe dataset analysed this manual is presented in Chapter 2. The associated files that we will use here are:\n\n\nGenomics data:\n\ngenomics_dataset.csv: contains the genomic variants’ dosage, with genomic variants as rows and samples as columns.\ngenomics_features_info.csv: contains information about the genomic variants (chromosome, genomic position, etc, as well as the results of a GWAS analysis).\n\n\n\nTranscriptomics data:\n\ntranscriptomics_dataset.csv: contains the raw read counts for the measured genes – rows correspond to transcripts, and columns to samples.\nbos_taurus_gene_model.gff3: the genome annotation file used to map the transcriptomics reads to gene models.\ntranscriptomics_de_results.csv: the results of a differential expression analysis run on the transcriptomics dataset to compare healthy and diseased animals.\ntranscriptomics_go_annotation.csv: contains the correspondence between genes and GO terms in a long format (one row per gene/GO term pair).\n\n\n\nMetabolomics data:\n\nmetabolomics_dataset.csv: contains the area peak values – rows correspond to samples, and columns to compounds.\nmetabolomics_features_info.csv: contains information about the compounds (such as mass, retention time, and formula and name if the compounds has been identified) as well as the results of a differential expression analysis run on the metabolomics dataset to compare healthy and diseased animals.\n\n\nSamples information: stored in the samples_info.csv file, in which each row corresponds to a sample.\n\nEach of these files is available through the moiraine package, and can be retrieved via system.file(\"extdata/genomics_dataset.csv\", package = \"moiraine\")."
  },
  {
    "objectID": "data_import.html#importing-the-datasets",
    "href": "data_import.html#importing-the-datasets",
    "title": "3  Importing data",
    "section": "\n3.2 Importing the datasets",
    "text": "3.2 Importing the datasets\nWe will show how to import the datasets, first manually, and then in an automated way (using a target factory function).\n\n3.2.1 Manually\nWe can start by creating targets that track the different data files. This ensures that when a data file changes, the target is considered outdated and any analysis relying on this data file will be re-run (see here for more information). For example, for the genomics dataset, we write:\n\ntar_target(\n  dataset_file_geno,\n  system.file(\"extdata/genomics_dataset.csv\", package = \"moiraine\"),\n  format = \"file\"\n)\n\nThe created target, called dataset_file_geno, takes as value the path to the file:\n\ntar_read(dataset_file_geno)\n#> [1] \"/powerplant/workspace/hrpoab/RENV_CACHE/v5/R-4.2/x86_64-pc-linux-gnu/moiraine/0.0.0.9000/a0cb1ab1c9bfde027266aa5d81f33617/moiraine/extdata/genomics_dataset.csv\"\n\nThe next step is to import this dataset in R. We use the import_dataset_csv() function for that, rather than the readr::read_csv() or similar functions, as it ensures that the data is imported with the correct format for further use with the moiraine package. When importing a dataset, we need to specify the path to the file, as well as the name of the column in the csv file that contains the row names (through the col_id argument). In addition, we need to specify whether the features are represented in rows in the csv file, or in columns. This is done through the argument features_as_rows. For example, we can load the genomics dataset through:\n\ntar_target(\n  data_geno,\n  import_dataset_csv(\n    dataset_file_geno, \n    col_id = \"marker\", \n    features_as_rows = TRUE)\n)\n\nThe function returns a matrix in which the rows correspond to the features measured, and the columns correspond to the samples:\n\ntar_read(data_geno) |> dim()\n#> [1] 23036   139\ntar_read(data_geno)[1:5, 1:3]\n#>                             R21 Y3660 Y3243\n#> 1_41768691                    1     0     2\n#> 10-27008241-A-C-rs42918694    2     2     2\n#> 10-37505419-T-C-rs136559242   0     1     0\n#> 10-49904259-G-A-rs471723345   1     2     2\n#> 1-109550832-G-A-rs209732846   2     2     1\n\nNote that import_dataset_csv() uses readr::read_csv() to read in the data. It accepts arguments that will be passed on to read_csv(), which can be useful to control how the data file must be read, e.g. by specifying the columns’ type, or which characters must be considered as missing values.\n\n3.2.2 Using a target factory function\nCreating a target to track the raw file and using the import_dataset_csv() function to read it can be a bit cumbersome if we want to import several datasets. Luckily, this process can be automated with the import_dataset_csv_factory() function. It takes as an input a vector of files path, and for each file creates:\n\na target named dataset_file_XX (XX explained below), which tracks the raw data file;\na target named data_XX, which corresponds to the data matrix that has been imported through the import_dataset_csv function.\n\nFor each file, we need to specify the name of the column giving the row names (argument col_ids), and whether the features are stored as rows or as columns (argument features_as_rowss). Note that these arguments are the same as in the primary function import_dataset_csv(), except that they have an additional ‘s’ at the end of their name. This will be the case for most of the target factory functions from the package.\nIn addition, we have to provide a unique suffix which will be appended to the name of the targets created (i.e. the XX mentioned above) through the target_name_suffixes argument. This allows us to track which target corresponds to which dataset.\nSo the following code (note that it is not within a tar_target() call):\n\nimport_dataset_csv_factory(\n  files = c(\n    system.file(\"extdata/genomics_dataset.csv\", package = \"moiraine\"),\n    system.file(\"extdata/transcriptomics_dataset.csv\", package = \"moiraine\"),\n    system.file(\"extdata/metabolomics_dataset.csv\", package = \"moiraine\")\n  ),\n  col_ids = c(\"marker\", \"gene_id\", \"sample_id\"),\n  features_as_rowss = c(TRUE, TRUE, FALSE),\n  target_name_suffixes = c(\"geno\", \"transcripto\", \"metabo\")\n)\n\nwill create the following targets:\n\ndataset_file_geno, dataset_file_transcripto, dataset_file_metabo\ndata_geno, data_metabo, data_transcripto\n\n\ntar_read(data_geno) |> dim()\n#> [1] 23036   139\ntar_read(data_transcripto) |> dim()\n#> [1] 20335   143\ntar_read(data_metabo) |> dim()\n#> [1]  55 139\n\nWith this factory function, it is not possible to pass arguments to read_csv(). If you want to control how the files are read, please use the import_dataset_csv() function directly instead, as shown in Section 3.2.1."
  },
  {
    "objectID": "data_import.html#importing-the-features-metadata",
    "href": "data_import.html#importing-the-features-metadata",
    "title": "3  Importing data",
    "section": "\n3.3 Importing the features metadata",
    "text": "3.3 Importing the features metadata\nSimilarly to how we imported the datasets, there are two ways of importing features metadata: either manually, or using a target factory function. The two options are illustrated below.\n\n3.3.1 Manually\nAs shown in the previous section, we can start by creating a target that tracks the raw features metadata file, then read the file into R using the import_fmetadata_csv() function. It has the similar arguments as the import_dataset_csv() function, but returns a data-frame (rather than a matrix); and does not have the options to read a csv where the features are columns (they must be in rows):\n\nlist(\n  tar_target(\n    fmetadata_file_geno,\n    system.file(\"extdata/genomics_features_info.csv\", package = \"moiraine\"),\n    format = \"file\"\n  ),\n  \n  tar_target(\n    fmetadata_geno,\n    import_fmetadata_csv(\n      fmetadata_file_geno,\n      col_id = \"marker\",\n      col_types = c(\"chromosome\" = \"c\")\n    )\n  )\n)\n\nNotice that in the import_fmetadata_csv() call, we’ve added an argument (col_types) which will be passed on to read_csv(). This is to ensure that the chromosome column will be read as character (even though the chromosomes are denoted with integers).\n\ntar_read(fmetadata_geno) |> head()\n#>                                                feature_id chromosome  position\n#> 1_41768691                                     1_41768691          1  42139849\n#> 10-27008241-A-C-rs42918694     10-27008241-A-C-rs42918694         10  26971270\n#> 10-37505419-T-C-rs136559242   10-37505419-T-C-rs136559242         10  37388728\n#> 10-49904259-G-A-rs471723345   10-49904259-G-A-rs471723345          0         0\n#> 1-109550832-G-A-rs209732846   1-109550832-G-A-rs209732846          1 108696486\n#> 11-104555023-A-G-rs109353933 11-104555023-A-G-rs109353933         11 104498929\n#>                              gen_train_score ref alt ilmn_strand\n#> 1_41768691                            0.6786   T   G         BOT\n#> 10-27008241-A-C-rs42918694            0.8050   A   C         TOP\n#> 10-37505419-T-C-rs136559242           0.7890   A   G         TOP\n#> 10-49904259-G-A-rs471723345           0.7970   A   G         TOP\n#> 1-109550832-G-A-rs209732846           0.8909   T   C         BOT\n#> 11-104555023-A-G-rs109353933          0.8673   T   C         BOT\n#>                              customer_strand norm_id qtl_type qtl_effect\n#> 1_41768691                               BOT       2     <NA>         NA\n#> 10-27008241-A-C-rs42918694               TOP       1     <NA>         NA\n#> 10-37505419-T-C-rs136559242              BOT       1     <NA>         NA\n#> 10-49904259-G-A-rs471723345              TOP       2     <NA>         NA\n#> 1-109550832-G-A-rs209732846              TOP       3     <NA>         NA\n#> 11-104555023-A-G-rs109353933             TOP       1     <NA>         NA\n#>                              p_value fdr\n#> 1_41768691                        NA  NA\n#> 10-27008241-A-C-rs42918694        NA  NA\n#> 10-37505419-T-C-rs136559242       NA  NA\n#> 10-49904259-G-A-rs471723345       NA  NA\n#> 1-109550832-G-A-rs209732846       NA  NA\n#> 11-104555023-A-G-rs109353933      NA  NA\n\nYou can see that in the data-frame of features metadata, the feature IDs are present both as row names and in the feature_id column. This makes it easier to subset the datasets later on.\n\n3.3.2 Using a target factory function\nAlternatively, we can use a target factory function that automates the process when we have to read in several features metadata files. In our case, we have to do it for the genomics and metabolomics datasets only, as the transcriptomics dataset has a different features metadata format. However because we need to specify the column types for the genomics dataset, we will use the targets factory function to read in the metabolomics features metadata only. The arguments are almost the same as for import_dataset_csv_factory() (except for features_as_rowss):\n\nimport_fmetadata_csv_factory(\n  files = c(\n    system.file(\"extdata/metabolomics_features_info.csv\", package = \"moiraine\")\n  ),\n  col_ids = c(\"feature_id\"),\n  target_name_suffixes = c(\"metabo\")\n)\n\nThe targets created are:\n\nfmetadata_file_metabo\nfmetadata_metabo\n\n\ntar_read(fmetadata_metabo) |> head()\n#>           feature_id     hmdb_id                  name chemical_formula\n#> HMDB00001  HMDB00001 HMDB0000001     1-Methylhistidine        C7H11N3O2\n#> HMDB00008  HMDB00008 HMDB0000008 2-Hydroxybutyric acid           C4H8O3\n#> HMDB00357  HMDB00357 HMDB0000011 3-Hydroxybutyric acid           C4H8O3\n#> HMDB00042  HMDB00042 HMDB0000042           Acetic acid           C2H4O2\n#> HMDB00043  HMDB00043 HMDB0000043               Betaine         C5H12NO2\n#> HMDB00060  HMDB00060 HMDB0000060      Acetoacetic acid           C4H6O3\n#>           monisotopic_molecular_weight cas_registry_number\n#> HMDB00001                    169.08513            332-80-9\n#> HMDB00008                    104.04734           3347-90-8\n#> HMDB00357                    104.04734            625-72-9\n#> HMDB00042                     60.02113             64-19-7\n#> HMDB00043                    118.08680           6915-17-9\n#> HMDB00060                    102.03169            541-50-4\n#>                                smiles                    inchikey kegg_id\n#> HMDB00001 CN1C=NC(C[C@H](N)C(O)=O)=C1 BRMWTNUJHUMWMS-LURJTMIESA-N  C01152\n#> HMDB00008            CC[C@H](O)C(O)=O AFENDNXGAFYKQO-VKHMYHEASA-N  C05984\n#> HMDB00357           C[C@@H](O)CC(O)=O WHBMMWSBFZVSSR-GSVOUGTGSA-N  C01089\n#> HMDB00042                     CC(O)=O QTBSBXVTEAMEQO-UHFFFAOYSA-N  C00033\n#> HMDB00043          C[N+](C)(C)CC(O)=O KWIUHFFTVRNATP-UHFFFAOYSA-O    <NA>\n#> HMDB00060               CC(=O)CC(O)=O WDJHALXBUFZDSR-UHFFFAOYSA-N  C00164\n#>                                    direct_parent                   super_class\n#> HMDB00001              Histidine and derivatives Organic acids and derivatives\n#> HMDB00008    Alpha hydroxy acids and derivatives Organic acids and derivatives\n#> HMDB00357     Beta hydroxy acids and derivatives Organic acids and derivatives\n#> HMDB00042                       Carboxylic acids Organic acids and derivatives\n#> HMDB00043                      Alpha amino acids Organic acids and derivatives\n#> HMDB00060 Short-chain keto acids and derivatives Organic acids and derivatives\n#>               t_value      p_value         padj de_signif     de_status\n#> HMDB00001  -0.5557020 5.797635e-01 6.784466e-01    Not DE        Not DE\n#> HMDB00008   0.2181562 8.276321e-01 8.925444e-01    Not DE        Not DE\n#> HMDB00357  -9.7388879 2.353250e-17 2.157146e-16        DE downregulated\n#> HMDB00042 -12.5323491 1.753101e-24 4.821028e-23        DE downregulated\n#> HMDB00043  -7.9073179 7.827088e-13 3.913544e-12        DE downregulated\n#> HMDB00060  -0.4369834 6.628164e-01 7.439776e-01    Not DE        Not DE\n\nAgain, the targets factory function does not allow to pass arguments to readr::read_csv() (if you need them, please use import_fmetadata_csv() directly as we have done in Section 3.3.1).\n\n3.3.3 Importing features metadata from a GTF/GFF file\nThe moiraine package can also extract features metadata from a genome annotation file (.gtf or .gff). We’ll demonstrate that for the transcriptomics dataset, for which information about the position and name of the transcripts can be found in the genome annotation used to map the reads. The function is called import_fmetadata_gff() (it is also the function you would use to read in information from a .gtf file). The type of information to extract from the annotation file is specified through the feature_type argument, which can be either 'genes' or 'transcripts'. In addition, if the function does not extract certain fields from the annotation file, these can be explicitly called using the add_fields parameter.\nIn this example, we want to extract information about the genes from the gtf file. We also want to make sure that the Name and descriptionfield are imported, as they give the name and description of the genes. To read in this information “manually”, we create the following targets:\n\nlist(\n  tar_target(\n    fmetadata_file_transcripto,\n    system.file(\"extdata/bos_taurus_gene_model.gff3\", package = \"moiraine\"),\n    format = \"file\"\n  ),\n  \n  tar_target(\n    fmetadata_transcripto,\n    import_fmetadata_gff(\n      fmetadata_file_transcripto,\n      feature_type = \"genes\",\n      add_fields = c(\"Name\", \"description\")\n    )\n  )\n)\n\nAs for the other import functions, there exists a more succinct target factory version, called import_fmetadata_gff_factory():\n\nimport_fmetadata_gff_factory(\n  files = system.file(\"extdata/bos_taurus_gene_model.gff3\", package = \"moiraine\"),\n  feature_types = \"genes\",\n  add_fieldss = c(\"Name\", \"description\"),\n  target_name_suffixes = \"transcripto\"\n)\n\nThis will create two targets: fmetadata_file_transcripto and fmetadata_transcripto.\nAs with import_fmetadata, the function returns a data-frame of features information:\n\ntar_read(fmetadata_transcripto) |> head()\n#>                            feature_id chromosome    start      end  width\n#> ENSBTAG00000000005 ENSBTAG00000000005         17 65389743 65505336 115594\n#> ENSBTAG00000000008 ENSBTAG00000000008         29 32214439 32244810  30372\n#> ENSBTAG00000000009 ENSBTAG00000000009         18 12338037 12342272   4236\n#> ENSBTAG00000000010 ENSBTAG00000000010         21 34209956 34223394  13439\n#> ENSBTAG00000000011 ENSBTAG00000000011          8  7950815  7971600  20786\n#> ENSBTAG00000000012 ENSBTAG00000000012         20 33708626 33732944  24319\n#>                    strand  Name\n#> ENSBTAG00000000005      +  GRK3\n#> ENSBTAG00000000008      - KCNJ1\n#> ENSBTAG00000000009      + FOXF1\n#> ENSBTAG00000000010      +  UBL7\n#> ENSBTAG00000000011      -   TDH\n#> ENSBTAG00000000012      + TTC33\n#>                                                                                                       description\n#> ENSBTAG00000000005                        G protein-coupled receptor kinase 3 [Source:VGNC Symbol;Acc:VGNC:53904]\n#> ENSBTAG00000000008 potassium inwardly rectifying channel subfamily J member 1 [Source:VGNC Symbol;Acc:VGNC:30453]\n#> ENSBTAG00000000009                                            forkhead box F1 [Source:VGNC Symbol;Acc:VGNC:29084]\n#> ENSBTAG00000000010                                           ubiquitin like 7 [Source:VGNC Symbol;Acc:VGNC:50128]\n#> ENSBTAG00000000011                                 L-threonine dehydrogenase [Source:VGNC Symbol;Acc:VGNC:108945]\n#> ENSBTAG00000000012                         tetratricopeptide repeat domain 33 [Source:VGNC Symbol;Acc:VGNC:36471]"
  },
  {
    "objectID": "data_import.html#importing-the-samples-metadata",
    "href": "data_import.html#importing-the-samples-metadata",
    "title": "3  Importing data",
    "section": "\n3.4 Importing the samples metadata",
    "text": "3.4 Importing the samples metadata\nAs for importing datasets or features metadata, the import_smetadata_csv() function reads in a csv file that contains information about the samples measured. Similarly to import_fmetadata_csv(), this function assumes that the csv file contains samples as rows. In this example, we have one samples information file for all of our omics datasets, but it is possible to have one separate samples metadata csv file for each omics dataset (if there are some omics-specific information such as batch, technology specifications, etc).\nWe can do this by manually creating the following targets:\n\nlist(\n  tar_target(\n    smetadata_file_all,\n    system.file(\"extdata/samples_info.csv\", package = \"moiraine\"),\n    format = \"file\"\n  ),\n\n  tar_target(\n    smetadata_all,\n    import_smetadata_csv(\n      smetadata_file_all,\n      col_id = \"animal_id\"\n    )\n  )\n)\n\nwhich is equivalent to the (more succinct) command:\n\nimport_smetadata_csv_factory(\n  files = system.file(\"extdata/samples_info.csv\", package = \"moiraine\"),\n  col_ids = \"animal_id\",\n  target_name_suffixes = \"all\"\n)\n\nThe latter command creates the targets smetadata_file_all and smetadata_all. smetadata_all stores the samples metadata imported as a data-frame:\n\ntar_read(smetadata_all) |> head()\n#>          id feedlot gender  status day_on_feed rnaseq_batch geno_comp_1\n#> R21     R21      F1 female Control          31           B2    0.007853\n#> Y3660 Y3660      F1   male Control          19           B2    0.852220\n#> Y3243 Y3243      F1   male Control          16           B2    0.044171\n#> R5764 R5764      F2   male Control          46           B1    0.213094\n#> P4669 P4669      F3   male     BRD          35           B2    0.389393\n#> R5452 R5452      F2   male Control          49           B1    0.265998\n#>       geno_comp_2 geno_comp_3 geno_comp_cluster\n#> R21      0.820691    0.171456                K3\n#> Y3660    0.093585    0.054195                K2\n#> Y3243    0.190262    0.765567                K1\n#> R5764    0.676299    0.110607                K3\n#> P4669    0.503471    0.107136                K3\n#> R5452    0.733992    0.000010                K3\n\nNote that in the samples metadata data-frame, the sample IDs are present both as row names and in the id column. This makes it easier to subset the datasets later on.\nAs for the other import functions, import_smetadata_csv() accepts arguments that will be passed to readr::read_csv() in order to specify how the file should be read. The targets factory version does not have this option."
  },
  {
    "objectID": "data_import.html#creating-the-omics-sets",
    "href": "data_import.html#creating-the-omics-sets",
    "title": "3  Importing data",
    "section": "\n3.5 Creating the omics sets",
    "text": "3.5 Creating the omics sets\nOnce each dataset and associated features and samples metadata have been imported, we need to combine them into omics sets. In practice, this means that for each omics dataset, we will create an R object that stores the actual dataset alongside its relevant metadata. moiraine relies on the Biobase containers derived from Biobase::eSet to store the different omics datasets; for example, Biobase::ExpressionSet objects are used to store transcriptomics measurements. Currently, moiraine support four types of omics containers:\n\ngenomics containers, which are Biobase::SnpSet objects. The particularity of this data type is that the features metadata data-frame must contain a column named chromosome and a column named position, which store the chromosome and genomic position within the chromosome (in base pairs) of a given genomic marker or variant.\ntranscriptomics containers, which are Biobase::ExpressionSet objects. The particularity of this data type is that the features metadata data-frame must contain the following columns: chromosome, start, end, giving the chromosome, start and end positions (in base pairs) of the genes or transcripts. Moreover, the values in start and end must be integers, and for each row the value in end must be higher than the value in start.\nmetabolomics containers, which are MetabolomeSet objects (implemented within moiraine). There are no restrictions on the features metadata table for this type of containers.\nphenotype containers, which are PhenotypeSet objects (implemented within moiraine). There are no restrictions on the features metadata table for this type of containers.\n\nIn practice, the nuances between these different containers are not very important, and the type of container used to store a particular dataset will have no impact on the downstream analysis apart from the name that will be given to the omics dataset. So in order to create a container for a transcriptomics dataset in the absence of features metadata, we have to create a dummy data-frame with the columns chromosome, start and end containing the values ch1, 1, and 10 (for example) and use that as features metadata. Alternately, or for other omics data (e.g. proteomics), it is possible to use a PhenotypeSet object instead.\n\n3.5.1 Creating a single omics set\nThe function create_omics_set() provides a convenient wrapper to create such container objects from the imported datasets and metadata. It has two mandatory arguments: the dataset, which should be in the form of a matrix where the rows correspond to features and the columns to samples; and the type of omics data that the dataset represents ('genomics', 'transcriptomics', 'metabolomics' or 'phenomics'). The latter determines which type of container will be generated. Optionally, a features metadata and/or a samples metadata data-frame can be passed on via the features_metadata and samples_metadata arguments, respectively. For example, let’s create a set for the genomics data:\n\ntar_target(\n  set_geno,\n  create_omics_set(\n    data_geno,\n    omics_type = \"genomics\",\n    features_metadata = fmetadata_geno,\n    samples_metadata = smetadata_all\n  )\n)\n\nIf executed, this command will return the following warning:\n\n#> Warning: 5 samples in samples metadata not in dataset, will be removed from\n#> metadata.\n\nThis is because, when providing features and samples metadata information, the function makes sure that the feature or sample IDs present in the metadata tables match those used in the dataset. In our case, 5 sample IDs from the metadata data-frame are not present in the dataset. We can confirm that by comparing the column names of the genomics dataset to the row names of the samples metadata:\n\nsetdiff(\n  tar_read(smetadata_all) |> rownames(),\n  tar_read(data_geno) |> colnames()\n)\n#> [1] \"P4744\" \"P4772\" \"R8953\" \"U5416\" \"R9909\"\n\nRather than throwing an error, the function will add a row for each missing sample ID to the metadata data-frame, with a NA in every column, and will remove from the metadata data-frame any sample not present in the dataset. The same applies for features metadata.\nThe resulting object is a SnpSet:\n\ntar_read(set_geno)\n#> SnpSet (storageMode: lockedEnvironment)\n#> assayData: 23036 features, 139 samples \n#>   element names: call, callProbability \n#> protocolData: none\n#> phenoData\n#>   rowNames: R21 Y3660 ... O5108 (139 total)\n#>   varLabels: id feedlot ... geno_comp_cluster (10 total)\n#>   varMetadata: labelDescription\n#> featureData\n#>   featureNames: 1_41768691 10-27008241-A-C-rs42918694 ... STAT5_13516_2\n#>     (23036 total)\n#>   fvarLabels: feature_id chromosome ... fdr (13 total)\n#>   fvarMetadata: labelDescription\n#> experimentData: use 'experimentData(object)'\n#> Annotation:\n\nwhich can be queried using specific methods from the Biobase package, e.g.:\n\ntar_load(set_geno)\n\ndim(set_geno)\n#> Features  Samples \n#>    23036      139\n\nfeatureNames(set_geno) |> head()\n#> [1] \"1_41768691\"                   \"10-27008241-A-C-rs42918694\"  \n#> [3] \"10-37505419-T-C-rs136559242\"  \"10-49904259-G-A-rs471723345\" \n#> [5] \"1-109550832-G-A-rs209732846\"  \"11-104555023-A-G-rs109353933\"\n\nsampleNames(set_geno) |> head()\n#> [1] \"R21\"   \"Y3660\" \"Y3243\" \"R5764\" \"P4669\" \"R5452\"\n\nfData(set_geno) |> head() ## extracts features metadata\n#>                                                feature_id chromosome  position\n#> 1_41768691                                     1_41768691          1  42139849\n#> 10-27008241-A-C-rs42918694     10-27008241-A-C-rs42918694         10  26971270\n#> 10-37505419-T-C-rs136559242   10-37505419-T-C-rs136559242         10  37388728\n#> 10-49904259-G-A-rs471723345   10-49904259-G-A-rs471723345          0         0\n#> 1-109550832-G-A-rs209732846   1-109550832-G-A-rs209732846          1 108696486\n#> 11-104555023-A-G-rs109353933 11-104555023-A-G-rs109353933         11 104498929\n#>                              gen_train_score ref alt ilmn_strand\n#> 1_41768691                            0.6786   T   G         BOT\n#> 10-27008241-A-C-rs42918694            0.8050   A   C         TOP\n#> 10-37505419-T-C-rs136559242           0.7890   A   G         TOP\n#> 10-49904259-G-A-rs471723345           0.7970   A   G         TOP\n#> 1-109550832-G-A-rs209732846           0.8909   T   C         BOT\n#> 11-104555023-A-G-rs109353933          0.8673   T   C         BOT\n#>                              customer_strand norm_id qtl_type qtl_effect\n#> 1_41768691                               BOT       2     <NA>         NA\n#> 10-27008241-A-C-rs42918694               TOP       1     <NA>         NA\n#> 10-37505419-T-C-rs136559242              BOT       1     <NA>         NA\n#> 10-49904259-G-A-rs471723345              TOP       2     <NA>         NA\n#> 1-109550832-G-A-rs209732846              TOP       3     <NA>         NA\n#> 11-104555023-A-G-rs109353933             TOP       1     <NA>         NA\n#>                              p_value fdr\n#> 1_41768691                        NA  NA\n#> 10-27008241-A-C-rs42918694        NA  NA\n#> 10-37505419-T-C-rs136559242       NA  NA\n#> 10-49904259-G-A-rs471723345       NA  NA\n#> 1-109550832-G-A-rs209732846       NA  NA\n#> 11-104555023-A-G-rs109353933      NA  NA\n\npData(set_geno) |> head() ## extracts samples metadata\n#>          id feedlot gender  status day_on_feed rnaseq_batch geno_comp_1\n#> R21     R21      F1 female Control          31           B2    0.007853\n#> Y3660 Y3660      F1   male Control          19           B2    0.852220\n#> Y3243 Y3243      F1   male Control          16           B2    0.044171\n#> R5764 R5764      F2   male Control          46           B1    0.213094\n#> P4669 P4669      F3   male     BRD          35           B2    0.389393\n#> R5452 R5452      F2   male Control          49           B1    0.265998\n#>       geno_comp_2 geno_comp_3 geno_comp_cluster\n#> R21      0.820691    0.171456                K3\n#> Y3660    0.093585    0.054195                K2\n#> Y3243    0.190262    0.765567                K1\n#> R5764    0.676299    0.110607                K3\n#> P4669    0.503471    0.107136                K3\n#> R5452    0.733992    0.000010                K3\n\nNote that these methods can also be applied to the other types of containers.\n\n3.5.2 Using a target factory for creating omics sets\nThe function create_omics_set_factory() allows us to create several omics sets at once. It returns a list of targets, each storing one of the created omics set container. It takes as input arguments vectors that give for each omics set the arguments required by create_omics_set().\n\ncreate_omics_set_factory(\n  datasets = c(data_geno, data_transcripto, data_metabo),\n  omics_types = c(\"genomics\", \"transcriptomics\", \"metabolomics\"),\n  features_metadatas = c(fmetadata_geno, fmetadata_transcripto, fmetadata_metabo),\n  samples_metadatas = c(smetadata_all, smetadata_all, smetadata_all)\n)\n\nAgain, the warnings raised by the function originate from discrepancies between the datasets and associated metadata. It is always good practice to double-check manually to make sure that it is not due to a typo in the IDs or similar error.\nIf one of the datasets has no associated features or samples metadata, use NULL in the corresponding input arguments, e.g.:\n\ncreate_omics_set_factory(\n  datasets = c(data_geno, data_transcripto, data_metabo),\n  omics_types = c(\"genomics\", \"transcriptomics\", \"metabolomics\"),\n  features_metadatas = c(NULL, fmetadata_transcripto, fmetadata_metabo),\n  samples_metadatas = c(smetadata_all, NULL, smetadata_all)\n)\n\nThe create_omics_set_factory() function has a target_name_suffixes argument to customise the name of the created targets. However, if this argument is not provided, the function will attempt to read the suffixes to use from the name of the dataset targets. So in this case, it knows that the suffixes to use are 'geno', 'transcripto' and 'metabo'. Consequently, the function creates the following targets: set_geno, set_transcripto, set_metabo.\n\ntar_read(set_geno)\n#> SnpSet (storageMode: lockedEnvironment)\n#> assayData: 23036 features, 139 samples \n#>   element names: call, callProbability \n#> protocolData: none\n#> phenoData\n#>   rowNames: R21 Y3660 ... O5108 (139 total)\n#>   varLabels: id feedlot ... geno_comp_cluster (10 total)\n#>   varMetadata: labelDescription\n#> featureData\n#>   featureNames: 1_41768691 10-27008241-A-C-rs42918694 ... STAT5_13516_2\n#>     (23036 total)\n#>   fvarLabels: feature_id chromosome ... fdr (13 total)\n#>   fvarMetadata: labelDescription\n#> experimentData: use 'experimentData(object)'\n#> Annotation:\n\n\ntar_read(set_transcripto)\n#> ExpressionSet (storageMode: lockedEnvironment)\n#> assayData: 20335 features, 143 samples \n#>   element names: exprs \n#> protocolData: none\n#> phenoData\n#>   rowNames: R9497 R5969 ... Y9816 (143 total)\n#>   varLabels: id feedlot ... geno_comp_cluster (10 total)\n#>   varMetadata: labelDescription\n#> featureData\n#>   featureNames: ENSBTAG00000000005 ENSBTAG00000000008 ...\n#>     ENSBTAG00000055314 (20335 total)\n#>   fvarLabels: feature_id chromosome ... description (8 total)\n#>   fvarMetadata: labelDescription\n#> experimentData: use 'experimentData(object)'\n#> Annotation:\n\n\ntar_read(set_metabo)\n#> MetabolomeSet (storageMode: lockedEnvironment)\n#> assayData: 55 features, 139 samples \n#>   element names: call \n#> protocolData: none\n#> phenoData\n#>   rowNames: R21 Y3660 ... U5416 (139 total)\n#>   varLabels: id feedlot ... geno_comp_cluster (10 total)\n#>   varMetadata: labelDescription\n#> featureData\n#>   featureNames: HMDB00001 HMDB00008 ... HMDB01881 (55 total)\n#>   fvarLabels: feature_id hmdb_id ... de_status (16 total)\n#>   fvarMetadata: labelDescription\n#> experimentData: use 'experimentData(object)'\n#> Annotation:"
  },
  {
    "objectID": "data_import.html#creating-the-multi-omics-set",
    "href": "data_import.html#creating-the-multi-omics-set",
    "title": "3  Importing data",
    "section": "\n3.6 Creating the multi-omics set",
    "text": "3.6 Creating the multi-omics set\nFinally, we can combine the different omics sets into one multi-omics set object. moiraine makes use of the MultiDataSet package for that. MultiDataSet (Hernandez-Ferrer et al. (2017)) implements a multi-omics data container that collects, in one R object, several omics datasets alongside their associated features and samples metadata. One of the main advantages of using a MultiDataSet container is that we can pass all of the information associated with a set of related omics datasets with only one R object. In addition, the MultiDataSet package implements a number of very useful functions. For example, it is possible to assess the samples that are common to several omics sets. This is particularly useful for data integration, as the moiraine package can automatically discard samples missing from one or more datasets prior to the integration step if needed. Note that sample matching between the different omics datasets is based on sample IDs, so they must be consistent between the different datasets.\nWe will create the multi-omics set with the create_multiomics_set() function. It requires a list of the omics sets (that we created via either create_omics_set() or create_omics_set_factory()) to include, and returns a MultiDataSet::MultiDataSet-class object.\n\ntar_target(\n  mo_set,\n  create_multiomics_set(\n    list(set_geno,\n         set_transcripto,\n         set_metabo)\n  )\n)\n\n\ntar_read(mo_set)\n#> Object of class 'MultiDataSet'\n#>  . assayData: 3 elements\n#>     . snps: 23036 features, 139 samples \n#>     . rnaseq: 20335 features, 143 samples \n#>     . metabolome: 55 features, 139 samples \n#>  . featureData:\n#>     . snps: 23036 rows, 13 cols (feature_id, ..., p_value)\n#>     . rnaseq: 20335 rows, 8 cols (feature_id, ..., Name)\n#>     . metabolome: 55 rows, 16 cols (feature_id, ..., de_signif)\n#>  . rowRanges:\n#>     . snps: YES\n#>     . rnaseq: YES\n#>     . metabolome: NO\n#>  . phenoData:\n#>     . snps: 139 samples, 10 cols (id, ..., geno_comp_3)\n#>     . rnaseq: 143 samples, 10 cols (id, ..., geno_comp_3)\n#>     . metabolome: 139 samples, 10 cols (id, ..., geno_comp_3)\n\nWithin the MultiDataSet object, each omics set is assigned a name. The name depends first on the omics container type: a SnpSet set will be named snps, an ExpressionSet set will be named rnaseq, a MetabolomeSet will be named metabolome and a PhenotypeSet will be called phenotypes. If several sets of the same type are provided, they will be assigned unique names, e.g. snps+1 and snps+2 (the + symbol used as separator is set in the MultiDataSet package and cannot be changed). Alternatively, we can provide custom names for the datasets, using the datasets_names argument. These will be added to the type name (e.g. snps+customname). For example:\n\ntar_target(\n  mo_set_with_names,\n  create_multiomics_set(\n    list(set_geno,\n         set_transcripto,\n         set_metabo),\n    datasets_names = c(\"CaptureSeq\", \"RNAseq\", \"LCMS\")\n  )\n)\n\nreturns:\n\ntar_read(mo_set_with_names)\n#> Object of class 'MultiDataSet'\n#>  . assayData: 3 elements\n#>     . snps+CaptureSeq: 23036 features, 139 samples \n#>     . rnaseq+RNAseq: 20335 features, 143 samples \n#>     . metabolome+LCMS: 55 features, 139 samples \n#>  . featureData:\n#>     . snps+CaptureSeq: 23036 rows, 13 cols (feature_id, ..., p_value)\n#>     . rnaseq+RNAseq: 20335 rows, 8 cols (feature_id, ..., Name)\n#>     . metabolome+LCMS: 55 rows, 16 cols (feature_id, ..., de_signif)\n#>  . rowRanges:\n#>     . snps+CaptureSeq: YES\n#>     . rnaseq+RNAseq: YES\n#>     . metabolome+LCMS: NO\n#>  . phenoData:\n#>     . snps+CaptureSeq: 139 samples, 10 cols (id, ..., geno_comp_3)\n#>     . rnaseq+RNAseq: 143 samples, 10 cols (id, ..., geno_comp_3)\n#>     . metabolome+LCMS: 139 samples, 10 cols (id, ..., geno_comp_3)\n\nImportantly, the create_multiomics_set() function makes sure that samples metadata is consistent across the datasets for common samples. That is, if the same column (i.e. with the same name) is present in the samples metadata of several omics datasets, the values in this column must match for each sample present in all datasets. Otherwise, the function returns an error.\nIn the following chapter on Inspecting the MultiDataSet object, we will see how to handle the MultiDataSet object we just created. Alternatively, the MultiDataSet package vignette provides examples of constructing, querying and subsetting MultiDataSet objects."
  },
  {
    "objectID": "data_import.html#recap-targets-list",
    "href": "data_import.html#recap-targets-list",
    "title": "3  Importing data",
    "section": "\n3.7 Recap – targets list",
    "text": "3.7 Recap – targets list\nFor convenience, here is the list of targets that we created in this section:\n\nTargets list for data import\n\nlist(\n  ## Data import using a target factory\n  import_dataset_csv_factory(\n    files = c(\n      system.file(\"extdata/genomics_dataset.csv\", package = \"moiraine\"),\n      system.file(\"extdata/transcriptomics_dataset.csv\", package = \"moiraine\"),\n      system.file(\"extdata/metabolomics_dataset.csv\", package = \"moiraine\")\n    ),\n    col_ids = c(\"marker\", \"gene_id\", \"sample_id\"),\n    features_as_rowss = c(TRUE, TRUE, FALSE),\n    target_name_suffixes = c(\"geno\", \"transcripto\", \"metabo\")\n  ),\n  \n  ## Genomics features metadata file\n  tar_target(\n    fmetadata_file_geno,\n    system.file(\"extdata/genomics_features_info.csv\", package = \"moiraine\"),\n    format = \"file\"\n  ),\n  \n  ## Genomics features metadata import\n  tar_target(\n    fmetadata_geno,\n    import_fmetadata_csv(\n      fmetadata_file_geno,\n      col_id = \"marker\",\n      col_types = c(\"chromosome\" = \"c\")\n    )\n  ),\n  \n  \n  ## Metabolomics features metadata import\n  import_fmetadata_csv_factory(\n    files = c(\n      system.file(\"extdata/metabolomics_features_info.csv\", package = \"moiraine\")\n    ),\n    col_ids = c(\"feature_id\"),\n    target_name_suffixes = c(\"metabo\")\n  ),\n  \n  ## Transcriptomics features metadata import\n  import_fmetadata_gff_factory(\n    files = system.file(\"extdata/bos_taurus_gene_model.gff3\", package = \"moiraine\"),\n    feature_types = \"genes\",\n    add_fieldss = c(\"Name\", \"description\"),\n    target_name_suffixes = \"transcripto\"\n  ),\n  \n  ## Samples metadata import\n  import_smetadata_csv_factory(\n    files = system.file(\"extdata/samples_info.csv\", package = \"moiraine\"),\n    col_ids = \"animal_id\",\n    target_name_suffixes = \"all\"\n  ),\n  \n  ## Creating omics sets for each dataset\n  create_omics_set_factory(\n    datasets = c(data_geno, data_transcripto, data_metabo),\n    omics_types = c(\"genomics\", \"transcriptomics\", \"metabolomics\"),\n    features_metadatas = c(fmetadata_geno, fmetadata_transcripto, fmetadata_metabo),\n    samples_metadatas = c(smetadata_all, smetadata_all, smetadata_all)\n  ),\n  \n  ## Creating the MultiDataSet object\n  tar_target(\n    mo_set,\n    create_multiomics_set(\n      list(set_geno,\n           set_transcripto,\n           set_metabo)\n    )\n  )\n)\n\n\n\n\n\nHernandez-Ferrer, Carles, Carlos Ruiz-Arenas, Alba Beltran-Gomila, and Juan R. González. 2017. “MultiDataSet: An r Package for Encapsulating Multiple Data Sets with Application to Omic Data Integration.” BMC Bioinformatics 18 (1): 36. https://doi.org/10.1186/s12859-016-1455-1."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Hernandez-Ferrer, Carles, Carlos Ruiz-Arenas, Alba Beltran-Gomila, and\nJuan R. González. 2017. “MultiDataSet: An r Package for\nEncapsulating Multiple Data Sets with Application to Omic Data\nIntegration.” BMC Bioinformatics 18 (1): 36. https://doi.org/10.1186/s12859-016-1455-1.\n\n\nLi, Jiyuan, Robert Mukiibi, Janelle Jiminez, Zhiquan Wang, Everestus C.\nAkanno, Edouard Timsit, and Graham S. Plastow. 2022. “Applying\nMulti-Omics Data to Study the Genetic Background of Bovine Respiratory\nDisease Infection in Feedlot Crossbred Cattle.” Frontiers in\nGenetics 13. https://www.frontiersin.org/articles/10.3389/fgene.2022.1046192."
  }
]